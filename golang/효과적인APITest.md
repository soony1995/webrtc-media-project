## 케이스별 효과적인 테스트 코드 작성 전력

### golang 테스트 개요  
    - _test.go 확장자를 가진 파일에 작성됩니다.
    - Table driven testing 패턴으로 작성합니다.
    
    - 테스트 cli   
        - 전체 코드 테스트
            go test ./...
    - 커버리지 테스트

### 테스트를 어렵게 만드는 요소
    - 결합도 & 응집도
        - 높은 결합도 (DB) 와 낮은 응집도(여러 목적을 위해 만들어진 코드)는 경게해야 한다.
    - 복잡한 매개변수와 반환 값
        - 하나의 함수가 너무 많은 매개변수를 가지고 있다면, 각 매개변수에 대한 가능한 모든 조합을 테스트 해야 할 수도 있기 때문에, 매개변수의 수가 증가하면 테스트의 복잡성은 기하급수적으로 증가하게 된다.
        - 매개변수, 리턴을 줄이기 위해서는 객체를 사용한다.
    - 고루틴 & 채널
        - 테스트가 실행되는 시점과 고루틴의 실행이 완료되는 시점이 다를 수 있어, 테스트 결과가 일관되지 않을 수 있습니다.
        - 채널에 값이 들어오지 않아 계속 대기하고 있는 경우 
    - 외부 의존성
        - 외부 리소스나 서비스에 의존하는 코드는 테스트 중에 해당 리소스나 서비스를 제어하기어렵고 이로인해 원하는 테스트 시나리오를 재현하기 어렵습니다. 데이터를 생성, 읽기, 수정 또는 삭제하는 경우, 테스트 시나리오에 필요한 데이터 관리가 어려워집니다. 테스트를 위해 초기 데이터 설정, 테스트 실행 후 데이터 정리 등이 필요할 수도 있습니다.
    - 전역 상태 관리 (기본 적으로 안티패턴임.)
        - 전역 상태는 여러 테스트 사이에서 공유되므로, 하나의 테스트가 다른 테스트에 영향을 줄 수 있습니다. 전역 상태에 대한 종속성으로 인해 테스트 코드의 복잡성이 증가하고, 유지보수가 어려워 질 수 있습니다.
    - 코드 수조와 설계 (중요)
        - API 서버를 설계한다면 프로젝트 구조는 Go Clean Architecture를 참고하는 것을 추천합니다.

    Golang에서는 성격에 따라서 project layout도 천차만별
        - flat structure
        - modularization
        - go standard project -> 참고 
        - 다들 적당히 알아서 한다. 

### Go Clean Architecture
    - 프레임워크 독립성
    - 비지니스 로직들은 UI, 데이터베이스, 웹 서버등의 외부요소에 상관없이 테스트 될 수 있어야 한다.
    - UI와 무관하게 만약 변경이 있더라도 비즈니스 로직들은 변경되지 않아야 한다.    
    
    4 가지 layer
    - repository
    - usecase
    - delivery 
    - domain 

### 테스트를 어렵게 만들 때 고려해야 하는 것들
    - 고루틴이나 채널을 사용하시는 경우에는 테스트를 위해서 다양한 고려가 필요합니다.
    - go clean architecture 사용 하자.

### 레이어별 테스트 UseCase
    - repository 
        - 해당 레이어에서는 데이터 베이스를 직접 접근하는 계층이기 때문에 의도한대로 데이터가 CRUD가 잘 되었는지 확인할 필요가 있다. 외부 의존성으로 부터 독립해야 한다.
        - 외부 의존성을 대체하는 방법
            - Docker
                - testcontainer-go (패키지)
            - In memory Database
                - docker는 실제로 내부 서버로 띄우는 방식이라면 In Memory 방식은 Stub 형태로
                원래 사용하는 드라이브를 in memory로 구현된 인터페이스로 대체하는 형태로 작성되어있습니다.             
            - mocking 
                - 간단한 로직은 괜찮은데, 고도화 되면 힘들어진다.
            - docker, in memory 방식을 선호한다.
    - useCase
        - 해당 레이어에서는 비즈니스 로직을 구현하는 계층이고 테스트 또한 로직에 좀 더 집중해서 작성이 필요합니다. 외부 의존성을 가지는 부분은 repository에서 처리를 하고 있기에 테스트를 셋업하는데 들어가는 노력을 최소화 할 필요가 있습니다.인터페이스를 기준으로 mocking 파일을 생성해주는 라이브러리들이 있는데 이를 활용합니다.
        - mockery (패키지)
    - Delivery 
        - HTTP API 기준으로 어떤 프레임워크를 사용했느냐에 따라 테스트를 하는 방식이 달라질 수 있음. 목적은 외부에서 올바른 요청이 들어왔는지 확인을 할 필요가 있습니다.

### 런타임에 정해지는 값들
    - 대표적으로 시간이나 생성 때 마다 만들어지는 ID 값이 대표적.
    - go-cmp 
        - 값을 비교하는 라이브러리
        - 런타임 시에 정해지는 값들에 대해서는 테스트를 무시하고 작성하는 것도 방법이 될 수 있습니다.

### 어쩔 수 없이 비대해지는 함수들
    - 기능개발 요구사항이 복잡해지면 비즈니스 로직이 커질수 밖에 없습니다. 응집도를 높이다 보면 도메인 내부에서도 내부함수들이 만들어지게 되는데 이때 여러 곳에서 불러질 경우 mocking에 어려움을겪게 됩니다.

### 고루틴 & 채널 테스트 케이스 작성 //TODO




